import java.nio.file.Paths

def jobName = "<%= job_name %>"
def statusJobName = "<%= status_job_name %>"
def jobPackageName = "<%= package_name %>"
def upstreamJobNames = [<%= upstream_jobs.each_key.map { |job_name| "'#{job_name}'" }.join(", ") %>]
def upstreamPackageNames = [<%= upstream_jobs.each_value.map { |package_name| "'#{package_name}'" }.join(", ") %>]
<%= render_template('library.pipeline') %>
def triggeredByUpstream = false
def upstreamBuilds = []

stage('waiting for upstream jobs to finish') {
    def triggerBuild    = getTriggerBuild(currentBuild)
    if (triggerBuild) {
        triggeredByUpstream = true;
    }
    else {
        triggeredByUpstream = false;
        triggerBuild = [null, null];
    }

    upstreamBuilds = getUpstreamBuilds(upstreamJobNames, triggerBuild[0], triggerBuild[1])
    if (upstreamBuilds == null)
    {
        currentBuild.result = 'NOT_BUILT';
        writeAndArchiveStatus(statusJobName, jobPackageName, 'UPSTREAM_FAILED', null)
        return;
    }
    def failedBuild = waitForUpstreamBuilds(upstreamBuilds)
    if (failedBuild) {
        currentBuild.result = 'NOT_BUILT';
        writeAndArchiveStatus(statusJobName, jobPackageName, 'UPSTREAM_FAILED', failedBuild)
        return
    }
}

if (currentBuild.result == 'NOT_BUILT')
{
    return;
}

node(label: 'autoproj-jenkins') {
    def fullWorkspaceDir = pwd()
    def autoproj = "${fullWorkspaceDir}/dev/.autoproj/bin/autoproj"
    dir('dev/install/log') { deleteDir() }

    def jobPackagePrefix = null
    def upstreamPackagePrefixes = null

    stage('bootstrap') {
        try  {
            <%= render_template('bootstrap.pipeline', seed: seed, poll: false, vcs: buildconf_vcs, gemfile: gemfile, autoproj_install_path: autoproj_install_path, vcs_credentials: vcs_credentials, indent: 12) %>
        }
        catch(err) {
            writeAndArchiveStatus(statusJobName, jobPackageName, 'BOOTSTRAP_FAILED', null)
            throw(err)
        }
            

        def jenkins_dependency_overrides = "<%= render_template 'jenkins_dependency_overrides.rb', escape: true, package_name: package_name, upstream_jobs: upstream_jobs %>"
        writeFile file: 'dev/autoproj/overrides.d/99_jenkins_dependency_overrides.rb',
            text: jenkins_dependency_overrides

        def packagePrefixes = sh(script: "${autoproj} locate --no-cache --prefix '${jobPackageName}' ${upstreamPackageNames.join(" ")}", returnStdout: true).
            split("\n")

        jobPackagePrefix        = packagePrefixes[0]
        upstreamPackagePrefixes = packagePrefixes.tail()
    }

    stage('install upstream artifacts') {
        installUpstreamArtifacts(autoproj, fullWorkspaceDir,
            jobPackageName, jobPackagePrefix,
            upstreamJobNames, upstreamPackagePrefixes, upstreamBuilds)
    }

    try {
        dir('dev') {
            stage('prepare build') {
                <%= render_template("import-#{vcs.type}.pipeline",
                                    poll: true,
                                    patch: true,
                                    allow_unused: true,
                                    package_dir: package_dir,
                                    vcs: vcs,
                                    credentials: vcs_credentials.for(vcs),
                                    package_name: package_name,
                                    indent: 12) %>
                sh "${autoproj} test disable '<%= package_name %>'"
                sh "${autoproj} osdeps '<%= package_name %>' 'pkg-config'"
            }

            stage('build') {
                    sh "${autoproj} build --force --deps=f '<%= package_name %>' -p1"
                }
                archiveBuildLogs('', jobPackageName)
            }
    }
    catch(err) {
        archiveBuildLogs('', jobPackageName)
        writeAndArchiveStatus(statusJobName, jobPackageName, 'BUILD_FAILED', null)
        throw(err)
    }

    stage('handle downstream') {
        handleDownstream(autoproj, fullWorkspaceDir,
            jobName, jobPackagePrefix, "<%= artifact_glob %>")
        if (! triggeredByUpstream) {
            def json = '[<%= downstream_jobs.keys.map { |job_name| "\"#{job_name}\"" }.join(", ") %>]'
            def downstream_jobs = readJSON text: json
            triggerDownstreamJobs(downstream_jobs)
        }
    }

    def autoproj_test_failed = false
    stage('tests') {
        def test_timestamp_path = "${fullWorkspaceDir}/test-timestamp"
        touch file: test_timestamp_path
        def test_output_path    = "${fullWorkspaceDir}/test"
        dir('dev')
        {
            try {
                sh "${autoproj} test enable '<%= package_name %>'"
                sh "${autoproj} osdeps '<%= package_name %>'"
                sh "${autoproj} build --deps=f '<%= package_name %>' -p1"
                sh "${autoproj} test -p=1 '<%= package_name %>'"
            }
            catch(err) { autoproj_test_failed = true }

            try { sh "${autoproj} jenkins postprocess-tests --after=${test_timestamp_path} ${test_output_path} '<%= package_name %>'" }
            catch(err) { autoproj_test_failed = err }
        }
        try { junit allowEmptyResults: true, keepLongStdio: true, testResults: "test/*.xml" }
        catch(err) { autoproj_test_failed = err }

        if (autoproj_test_failed) {
            currentBuild.result = 'UNSTABLE'
        }
    }

    stage('wrap-up') {
        archiveBuildLogs('dev/', jobPackageName)
        if (autoproj_test_failed) {
            writeAndArchiveStatus(statusJobName, jobPackageName, 'TEST_FAILED', null)
        }
        else {
            writeAndArchiveStatus(statusJobName, jobPackageName, 'SUCCESS', null)
        }
        archiveArtifacts 'status.json'

        // Move the current package prefix to a separate folder, to ensure that
        // other workspaces don't have access to it. It's not strictly required,
        // but is a good sanity check
        dir('lastPrefix') { deleteDir() }
        sh "mv '${jobPackagePrefix}' lastPrefix"
    }
}

