import java.nio.file.Paths

def jobPackageName = "<%= package_name %>"
def upstreamJobNames = [<%= upstream_jobs.each_key.map { |job_name| "'#{job_name}'" }.join(", ") %>]
def upstreamPackageNames = [<%= upstream_jobs.each_value.map { |package_name| "'#{package_name}'" }.join(", ") %>]

stage 'waiting for upstream jobs to finish'
<%= render_template('wait-upstream.pipeline') %>

node<%= "(label: 'master')" if dev %> {
    dir('dev/install/log') { deleteDir() }

    stage 'bootstrap'
    <%= render_template('bootstrap.pipeline', vcs: buildconf_vcs, gemfile: gemfile, autoproj_install_path: autoproj_install_path, vcs_credentials: vcs_credentials, indent: 4) %>
    stage 'install upstream artifacts'

    def upstreamDir = "artifacts/upstream"
    def packagePrefixes = sh(script: "${autoproj} locate --no-cache --prefix '${jobPackageName}' ${upstreamPackageNames.join(" ")}", returnStdout: true).
    split("\n")

    def jobPackagePrefix = packagePrefixes[0]
    def upstreamPackagePrefixes = packagePrefixes.tail()

    parallel(makeUpstreamArtifactImporters(
            autoproj, fullWorkspaceDir, upstreamDir,
            upstreamJobNames, upstreamPackagePrefixes, upstreamBuilds)
    )

    if (fileExists("lastPrefix")) {
        sh "mv lastPrefix '${jobPackagePrefix}'"
    }

    def jenkins_dependency_overrides = "<%= render_template 'jenkins_dependency_overrides.rb', escape: true, package_name: package_name, upstream_jobs: upstream_jobs %>"
    writeFile file: 'dev/autoproj/overrides.d/99_jenkins_dependency_overrides.rb',
        text: jenkins_dependency_overrides

    dir('dev') {
        stage 'prepare build'
        <%= render_template("import-#{vcs.type}.pipeline",
                            allow_unused: true,
                            package_dir: package_dir,
                            vcs: vcs,
                            credentials: vcs_credentials.for(vcs),
                            package_name: package_name,
                            indent: 8) %>
        sh "${autoproj} test disable '<%= package_name %>'"
        sh "${autoproj} osdeps '<%= package_name %>' 'pkg-config'"

        stage 'build'
        try {
            sh "${autoproj} build --force --deps=f '<%= package_name %>' -p1"
        }
        catch(err) {
            archive includes: 'install/<%= package_name %>/log/<%= package_name %>-*.log'
            throw(err)
        }
        archive includes: 'install/<%= package_name %>/log/<%= package_name %>-*.log'
    }

    stage 'trigger dependencies'
    <%= render_template('handle-downstream.pipeline',
                        job_name: job_name,
                        artifact_glob: artifact_glob,
                        downstream_jobs: downstream_jobs,
                        indent: 4) %>

    stage 'tests'
    def test_timestamp_path = "${fullWorkspaceDir}/test-timestamp"
    touch file: test_timestamp_path
    def test_output_path    = "${fullWorkspaceDir}/test"
    def autoproj_test_failed = false
    dir('dev')
    {
        try {
            sh "${autoproj} test enable '<%= package_name %>'"
            sh "${autoproj} osdeps '<%= package_name %>'"
            sh "${autoproj} build --deps=f '<%= package_name %>' -p1"
            sh "${autoproj} test -p=1 '<%= package_name %>'"
        }
        catch(err) { autoproj_test_failed = true }

        try { sh "${autoproj} jenkins postprocess-tests --after=${test_timestamp_path} ${test_output_path} '<%= package_name %>'" }
        catch(err) { autoproj_test_failed = true }
    }
    junit allowEmptyResults: true, keepLongStdio: true, testResults: "test/*.xml"
    if (autoproj_test_failed)
    {
        currentBuild.result = 'UNSTABLE'
    }

    // Move the current package prefix to a separate folder, to ensure that
    // other workspaces don't have access to it. It's not strictly required,
    // but is a good sanity check
    dir('lastPrefix') { deleteDir() }
    sh "mv '${jobPackagePrefix}' lastPrefix"
}

